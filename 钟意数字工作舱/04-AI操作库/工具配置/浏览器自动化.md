# 浏览器自动化配置

## 📝 使用说明
这个文件包含了浏览器自动化的配置方法和代码片段，支持Selenium、Playwright等主流自动化工具。每个配置都经过测试，可以直接使用。

## 🚀 Selenium配置

### 基础配置
```python
from selenium import webdriver
from selenium.webdriver.common.by import By
from selenium.webdriver.support.ui import WebDriverWait
from selenium.webdriver.support import expected_conditions as EC
from selenium.webdriver.chrome.options import Options
from selenium.webdriver.common.action_chains import ActionChains
import time

# Chrome浏览器配置
def setup_chrome_driver(headless=False, window_size=(1920, 1080)):
    """设置Chrome浏览器驱动"""
    options = Options()

    if headless:
        options.add_argument('--headless')

    # 基础配置
    options.add_argument(f'--window-size={window_size[0]},{window_size[1]}')
    options.add_argument('--no-sandbox')
    options.add_argument('--disable-dev-shm-usage')
    options.add_argument('--disable-gpu')
    options.add_argument('--disable-extensions')

    # 用户代理
    options.add_argument('--user-agent=Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36')

    # 禁用图片加载（提高速度）
    prefs = {
        "profile.managed_default_content_settings.images": 2,
        "profile.default_content_setting_values.notifications": 2
    }
    options.add_experimental_option("prefs", prefs)

    driver = webdriver.Chrome(options=options)
    driver.implicitly_wait(10)

    return driver

# Firefox浏览器配置
def setup_firefox_driver(headless=False):
    """设置Firefox浏览器驱动"""
    from selenium.webdriver.firefox.options import Options

    options = Options()

    if headless:
        options.add_argument('--headless')

    options.add_argument('--width=1920')
    options.add_argument('--height=1080')

    driver = webdriver.Firefox(options=options)
    driver.implicitly_wait(10)

    return driver
```

### 元素定位
```python
class ElementLocator:
    def __init__(self, driver):
        self.driver = driver
        self.wait = WebDriverWait(driver, 10)

    def find_element_safe(self, locator, timeout=10):
        """安全查找元素"""
        try:
            element = WebDriverWait(self.driver, timeout).until(
                EC.presence_of_element_located(locator)
            )
            return element
        except Exception as e:
            print(f"元素未找到: {locator}, 错误: {e}")
            return None

    def find_elements_safe(self, locator, timeout=10):
        """安全查找多个元素"""
        try:
            elements = WebDriverWait(self.driver, timeout).until(
                EC.presence_of_all_elements_located(locator)
            )
            return elements
        except Exception as e:
            print(f"元素未找到: {locator}, 错误: {e}")
            return []

    def click_element(self, locator, timeout=10):
        """点击元素"""
        element = self.find_element_safe(locator, timeout)
        if element:
            try:
                self.wait.until(EC.element_to_be_clickable(locator))
                element.click()
                return True
            except Exception as e:
                print(f"点击失败: {e}")
                return False
        return False

    def input_text(self, locator, text, timeout=10):
        """输入文本"""
        element = self.find_element_safe(locator, timeout)
        if element:
            try:
                element.clear()
                element.send_keys(text)
                return True
            except Exception as e:
                print(f"输入失败: {e}")
                return False
        return False
```

### 页面操作
```python
class PageOperations:
    def __init__(self, driver):
        self.driver = driver
        self.actions = ActionChains(driver)

    def scroll_to_element(self, element):
        """滚动到元素"""
        self.driver.execute_script("arguments[0].scrollIntoView(true);", element)
        time.sleep(1)

    def scroll_to_bottom(self):
        """滚动到页面底部"""
        self.driver.execute_script("window.scrollTo(0, document.body.scrollHeight);")
        time.sleep(1)

    def scroll_to_top(self):
        """滚动到页面顶部"""
        self.driver.execute_script("window.scrollTo(0, 0);")
        time.sleep(1)

    def switch_to_new_tab(self):
        """切换到新标签页"""
        self.driver.switch_to.window(self.driver.window_handles[-1])

    def close_current_tab(self):
        """关闭当前标签页"""
        self.driver.close()
        self.driver.switch_to.window(self.driver.window_handles[0])

    def wait_for_page_load(self, timeout=30):
        """等待页面加载完成"""
        WebDriverWait(self.driver, timeout).until(
            lambda driver: driver.execute_script("return document.readyState") == "complete"
        )

    def take_screenshot(self, filename):
        """截图"""
        self.driver.save_screenshot(filename)
        print(f"截图已保存: {filename}")
```

## 🎭 Playwright配置

### 基础配置
```python
from playwright.sync_api import sync_playwright
import asyncio
from playwright.async_api import async_playwright

# 同步模式配置
def setup_playwright_sync(browser_type='chromium', headless=False):
    """设置Playwright同步模式"""
    playwright = sync_playwright().start()

    if browser_type == 'chromium':
        browser = playwright.chromium.launch(headless=headless)
    elif browser_type == 'firefox':
        browser = playwright.firefox.launch(headless=headless)
    elif browser_type == 'webkit':
        browser = playwright.webkit.launch(headless=headless)

    context = browser.new_context(
        viewport={'width': 1920, 'height': 1080},
        user_agent='Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36'
    )

    page = context.new_page()

    return playwright, browser, context, page

# 异步模式配置
async def setup_playwright_async(browser_type='chromium', headless=False):
    """设置Playwright异步模式"""
    playwright = await async_playwright().start()

    if browser_type == 'chromium':
        browser = await playwright.chromium.launch(headless=headless)
    elif browser_type == 'firefox':
        browser = await playwright.firefox.launch(headless=headless)
    elif browser_type == 'webkit':
        browser = await playwright.webkit.launch(headless=headless)

    context = await browser.new_context(
        viewport={'width': 1920, 'height': 1080},
        user_agent='Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36'
    )

    page = await context.new_page()

    return playwright, browser, context, page
```

### 页面操作
```python
class PlaywrightOperations:
    def __init__(self, page):
        self.page = page

    async def navigate_to(self, url):
        """导航到指定URL"""
        await self.page.goto(url)
        await self.page.wait_for_load_state('networkidle')

    async def click_element(self, selector):
        """点击元素"""
        await self.page.click(selector)

    async def input_text(self, selector, text):
        """输入文本"""
        await self.page.fill(selector, text)

    async def get_text(self, selector):
        """获取元素文本"""
        return await self.page.text_content(selector)

    async def get_attribute(self, selector, attribute):
        """获取元素属性"""
        return await self.page.get_attribute(selector, attribute)

    async def wait_for_element(self, selector, timeout=30000):
        """等待元素出现"""
        await self.page.wait_for_selector(selector, timeout=timeout)

    async def scroll_to_element(self, selector):
        """滚动到元素"""
        await self.page.scroll_into_view_if_needed(selector)

    async def take_screenshot(self, filename):
        """截图"""
        await self.page.screenshot(path=filename)
        print(f"截图已保存: {filename}")
```

## 🔧 实用工具类

### 数据提取
```python
class DataExtractor:
    def __init__(self, driver):
        self.driver = driver

    def extract_table_data(self, table_selector):
        """提取表格数据"""
        table = self.driver.find_element(By.CSS_SELECTOR, table_selector)
        rows = table.find_elements(By.TAG_NAME, "tr")

        data = []
        for row in rows:
            cells = row.find_elements(By.TAG_NAME, "td")
            if cells:
                row_data = [cell.text for cell in cells]
                data.append(row_data)

        return data

    def extract_links(self, container_selector=None):
        """提取链接"""
        if container_selector:
            container = self.driver.find_element(By.CSS_SELECTOR, container_selector)
            links = container.find_elements(By.TAG_NAME, "a")
        else:
            links = self.driver.find_elements(By.TAG_NAME, "a")

        link_data = []
        for link in links:
            href = link.get_attribute("href")
            text = link.text
            if href:
                link_data.append({"url": href, "text": text})

        return link_data

    def extract_images(self, container_selector=None):
        """提取图片信息"""
        if container_selector:
            container = self.driver.find_element(By.CSS_SELECTOR, container_selector)
            images = container.find_elements(By.TAG_NAME, "img")
        else:
            images = self.driver.find_elements(By.TAG_NAME, "img")

        image_data = []
        for img in images:
            src = img.get_attribute("src")
            alt = img.get_attribute("alt")
            if src:
                image_data.append({"src": src, "alt": alt})

        return image_data
```

### 表单处理
```python
class FormHandler:
    def __init__(self, driver):
        self.driver = driver

    def fill_form(self, form_data):
        """填写表单"""
        for field, value in form_data.items():
            try:
                element = self.driver.find_element(By.NAME, field)
                element.clear()
                element.send_keys(value)
            except Exception as e:
                print(f"填写字段 {field} 失败: {e}")

    def select_dropdown(self, select_name, option_value):
        """选择下拉框选项"""
        from selenium.webdriver.support.ui import Select

        try:
            select_element = self.driver.find_element(By.NAME, select_name)
            select = Select(select_element)
            select.select_by_value(option_value)
        except Exception as e:
            print(f"选择下拉框 {select_name} 失败: {e}")

    def submit_form(self, form_selector=None):
        """提交表单"""
        try:
            if form_selector:
                form = self.driver.find_element(By.CSS_SELECTOR, form_selector)
                form.submit()
            else:
                submit_button = self.driver.find_element(By.CSS_SELECTOR, "input[type='submit']")
                submit_button.click()
        except Exception as e:
            print(f"提交表单失败: {e}")
```

### 等待策略
```python
class WaitStrategies:
    def __init__(self, driver):
        self.driver = driver
        self.wait = WebDriverWait(driver, 10)

    def wait_for_element_visible(self, locator, timeout=10):
        """等待元素可见"""
        try:
            element = WebDriverWait(self.driver, timeout).until(
                EC.visibility_of_element_located(locator)
            )
            return element
        except Exception as e:
            print(f"等待元素可见失败: {e}")
            return None

    def wait_for_element_clickable(self, locator, timeout=10):
        """等待元素可点击"""
        try:
            element = WebDriverWait(self.driver, timeout).until(
                EC.element_to_be_clickable(locator)
            )
            return element
        except Exception as e:
            print(f"等待元素可点击失败: {e}")
            return None

    def wait_for_text_present(self, locator, text, timeout=10):
        """等待文本出现"""
        try:
            element = WebDriverWait(self.driver, timeout).until(
                EC.text_to_be_present_in_element(locator, text)
            )
            return element
        except Exception as e:
            print(f"等待文本出现失败: {e}")
            return None

    def wait_for_url_contains(self, url_part, timeout=10):
        """等待URL包含指定部分"""
        try:
            WebDriverWait(self.driver, timeout).until(
                EC.url_contains(url_part)
            )
            return True
        except Exception as e:
            print(f"等待URL变化失败: {e}")
            return False
```

## 🧪 测试框架

### 基础测试类
```python
import unittest
from selenium import webdriver

class WebAutomationTest(unittest.TestCase):
    def setUp(self):
        """测试前准备"""
        self.driver = setup_chrome_driver(headless=True)
        self.locator = ElementLocator(self.driver)
        self.operations = PageOperations(self.driver)

    def tearDown(self):
        """测试后清理"""
        self.driver.quit()

    def test_page_title(self):
        """测试页面标题"""
        self.driver.get("https://www.example.com")
        title = self.driver.title
        self.assertIn("Example", title)

    def test_element_presence(self):
        """测试元素存在"""
        self.driver.get("https://www.example.com")
        element = self.locator.find_element_safe((By.TAG_NAME, "h1"))
        self.assertIsNotNone(element)

    def test_form_submission(self):
        """测试表单提交"""
        self.driver.get("https://www.example.com/form")
        form_handler = FormHandler(self.driver)
        form_data = {"name": "Test User", "email": "test@example.com"}
        form_handler.fill_form(form_data)
        form_handler.submit_form()

        # 验证提交结果
        success_message = self.locator.find_element_safe((By.CLASS_NAME, "success"))
        self.assertIsNotNone(success_message)

if __name__ == '__main__':
    unittest.main()
```

## 📊 性能监控

### 性能指标收集
```python
class PerformanceMonitor:
    def __init__(self, driver):
        self.driver = driver

    def get_page_load_time(self):
        """获取页面加载时间"""
        return self.driver.execute_script(
            "return performance.timing.loadEventEnd - performance.timing.navigationStart"
        )

    def get_dom_ready_time(self):
        """获取DOM准备时间"""
        return self.driver.execute_script(
            "return performance.timing.domContentLoadedEventEnd - performance.timing.navigationStart"
        )

    def get_network_metrics(self):
        """获取网络指标"""
        return self.driver.execute_script("""
            var performance = window.performance;
            var network = performance.getEntriesByType('navigation')[0];
            return {
                dns: network.domainLookupEnd - network.domainLookupStart,
                tcp: network.connectEnd - network.connectStart,
                request: network.responseStart - network.requestStart,
                response: network.responseEnd - network.responseStart
            };
        """)

    def get_resource_metrics(self):
        """获取资源指标"""
        return self.driver.execute_script("""
            var resources = performance.getEntriesByType('resource');
            var totalSize = 0;
            var totalTime = 0;

            resources.forEach(function(resource) {
                totalSize += resource.transferSize || 0;
                totalTime += resource.duration || 0;
            });

            return {
                totalResources: resources.length,
                totalSize: totalSize,
                totalTime: totalTime
            };
        """)
```

## 🔄 使用建议

### 最佳实践
- 使用显式等待而不是隐式等待
- 合理设置超时时间
- 使用Page Object模式组织代码
- 添加适当的错误处理

### 性能优化
- 使用无头模式进行测试
- 禁用图片和CSS加载
- 使用浏览器缓存
- 合理设置并发数

### 维护建议
- 定期更新浏览器驱动
- 使用稳定的选择器
- 添加日志记录
- 编写可重用的工具函数

## 📝 更新记录

### 版本历史
- **v1.0** (2025-01-07): 初始版本，包含基础自动化配置
- **v1.1** (计划中): 增加更多实用工具类
- **v1.2** (计划中): 优化性能和稳定性

### 贡献指南
- 分享有效的自动化脚本
- 提供使用反馈
- 建议改进方案
- 参与代码审查

**浏览器自动化配置持续更新中...** 🚀
